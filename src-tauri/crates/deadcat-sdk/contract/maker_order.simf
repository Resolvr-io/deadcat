// Maker Order Covenant
// SimplicityHL contract for Liquid
//
// A maker limit order locked as a covenant UTXO.
// Takers fill by constructing transactions that satisfy conservation invariants.
// Partial fills produce a remainder UTXO locked by the same covenant.

// ============================================================================
// Boolean helpers
// ============================================================================

fn not(bit: bool) -> bool {
    <u1>::into(jet::complement_1(<bool>::into(bit)))
}

fn ensure_zero_bit(b: bool) {
    assert!(not(b));
}

// ============================================================================
// Utility functions
// ============================================================================

fn get_input_script_hash(index: u32) -> u256 {
    unwrap(jet::input_script_hash(index))
}

fn get_output_script_hash(index: u32) -> u256 {
    unwrap(jet::output_script_hash(index))
}

// Note: jet::output_amount returns (Asset1, Amount1) â€” both asset and amount
// in a single introspection call. This is an Elements/Simplicity jet convention.
fn get_output_explicit_asset_amount(index: u32) -> (u256, u64) {
    let (asset, amount): (Asset1, Amount1) = unwrap(jet::output_amount(index));
    let asset_val: u256 = unwrap_right::<(u1, u256)>(asset);
    let amount_val: u64 = unwrap_right::<(u1, u256)>(amount);
    (asset_val, amount_val)
}

// Same convention: jet::input_amount returns (Asset1, Amount1).
fn get_input_explicit_asset_amount(index: u32) -> (u256, u64) {
    let (asset, amount): (Asset1, Amount1) = unwrap(jet::input_amount(index));
    let asset_val: u256 = unwrap_right::<(u1, u256)>(asset);
    let amount_val: u64 = unwrap_right::<(u1, u256)>(amount);
    (asset_val, amount_val)
}

// ============================================================================
// Arithmetic helpers
// ============================================================================

fn safe_multiply(a: u64, b: u64) -> u64 {
    let result: u128 = jet::multiply_64(a, b);
    let (high, low): (u64, u64) = <u128>::into(result);
    assert!(jet::is_zero_64(high));
    low
}

fn safe_add(a: u64, b: u64) -> u64 {
    let (carry, sum): (bool, u64) = jet::add_64(a, b);
    ensure_zero_bit(carry);
    sum
}

fn safe_subtract(a: u64, b: u64) -> u64 {
    let (borrow, diff): (bool, u64) = jet::subtract_64(a, b);
    ensure_zero_bit(borrow);
    diff
}

fn safe_add_32(a: u32, b: u32) -> u32 {
    let (carry, sum): (bool, u32) = jet::add_32(a, b);
    ensure_zero_bit(carry);
    sum
}

// ============================================================================
// NUMS key constant (for cosigner bypass)
// ============================================================================

fn nums_key() -> u256 {
    0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0
}

// ============================================================================
// Cosigner check
// ============================================================================

fn check_cosigner(i: u32, sig: Signature) {
    // Skip if COSIGNER_PUBKEY == NUMS (no cosigner configured)
    let is_nums: bool = jet::eq_256(param::COSIGNER_PUBKEY, nums_key());
    match is_nums {
        true => {},
        false => {
            // Build custom sighash: SHA256(prev_outpoint || output_asset || output_amount || output_script_hash)
            let ctx: Ctx8 = jet::sha_256_ctx_8_init();

            // input_prev_outpoint(i) = txid (32 bytes) + vout (4 bytes) = 36 bytes
            let (txid, vout): (u256, u32) = unwrap(jet::input_prev_outpoint(i));
            let ctx: Ctx8 = jet::sha_256_ctx_8_add_32(ctx, txid);
            let ctx: Ctx8 = jet::sha_256_ctx_8_add_4(ctx, vout);

            // output asset (32 bytes) + amount (8 bytes) via single introspection
            let (out_asset, out_amount): (u256, u64) = get_output_explicit_asset_amount(i);
            let ctx: Ctx8 = jet::sha_256_ctx_8_add_32(ctx, out_asset);
            let ctx: Ctx8 = jet::sha_256_ctx_8_add_8(ctx, out_amount);

            // output_script_hash(i) = 32 bytes
            let out_spk_hash: u256 = get_output_script_hash(i);
            let ctx: Ctx8 = jet::sha_256_ctx_8_add_32(ctx, out_spk_hash);

            let msg: u256 = jet::sha_256_ctx_8_finalize(ctx);
            jet::bip_0340_verify((param::COSIGNER_PUBKEY, msg), sig);
        },
    };
}

// ============================================================================
// Direction-specific fill validation
// ============================================================================

fn validate_sell_base_fill(i: u32, i_rem: u32) {
    // Maker sells BASE lots, receives QUOTE
    let (input_asset, input_amount): (u256, u64) = get_input_explicit_asset_amount(i);
    assert!(jet::eq_256(input_asset, param::BASE_ASSET_ID));

    let (maker_asset, maker_amount): (u256, u64) = get_output_explicit_asset_amount(i);
    assert!(jet::eq_256(maker_asset, param::QUOTE_ASSET_ID));

    // Check if full fill: maker_amount == input_amount * PRICE
    let expected_full: u64 = safe_multiply(input_amount, param::PRICE);
    let is_full: bool = jet::eq_64(maker_amount, expected_full);

    match is_full {
        true => {
            // Full fill: all lots consumed
            assert!(jet::le_64(param::MIN_FILL_LOTS, input_amount));
        },
        false => {
            // Partial fill
            let (rem_asset, rem_amount): (u256, u64) = get_output_explicit_asset_amount(i_rem);
            assert!(jet::eq_256(rem_asset, param::BASE_ASSET_ID));

            let consumed: u64 = safe_subtract(input_amount, rem_amount);
            let expected_payment: u64 = safe_multiply(consumed, param::PRICE);
            assert!(jet::eq_64(maker_amount, expected_payment));

            assert!(jet::le_64(param::MIN_FILL_LOTS, consumed));
            assert!(jet::le_64(param::MIN_REMAINDER_LOTS, rem_amount));

            // Remainder must be locked by the same covenant script
            let rem_spk_hash: u256 = get_output_script_hash(i_rem);
            let input_spk_hash: u256 = get_input_script_hash(i);
            assert!(jet::eq_256(rem_spk_hash, input_spk_hash));
        },
    };
}

fn validate_sell_quote_fill(i: u32, i_rem: u32) {
    // Maker sells QUOTE, receives BASE lots
    let (input_asset, input_amount): (u256, u64) = get_input_explicit_asset_amount(i);
    assert!(jet::eq_256(input_asset, param::QUOTE_ASSET_ID));

    let (maker_asset, maker_amount): (u256, u64) = get_output_explicit_asset_amount(i);
    assert!(jet::eq_256(maker_asset, param::BASE_ASSET_ID));

    // Check if full fill: maker_amount * PRICE == input_amount
    let expected_full: u64 = safe_multiply(maker_amount, param::PRICE);
    let is_full: bool = jet::eq_64(expected_full, input_amount);

    match is_full {
        true => {
            // Full fill: all quote consumed
            assert!(jet::le_64(param::MIN_FILL_LOTS, maker_amount));
        },
        false => {
            // Partial fill
            let (rem_asset, rem_amount): (u256, u64) = get_output_explicit_asset_amount(i_rem);
            assert!(jet::eq_256(rem_asset, param::QUOTE_ASSET_ID));

            // Conservation: maker_amount * PRICE + rem_amount == input_amount
            let maker_payment: u64 = safe_multiply(maker_amount, param::PRICE);
            let total: u64 = safe_add(maker_payment, rem_amount);
            assert!(jet::eq_64(total, input_amount));

            assert!(jet::le_64(param::MIN_FILL_LOTS, maker_amount));

            // Minimum remainder in quote units: MIN_REMAINDER_LOTS * PRICE
            let min_rem_quote: u64 = safe_multiply(param::MIN_REMAINDER_LOTS, param::PRICE);
            assert!(jet::le_64(min_rem_quote, rem_amount));

            // Remainder must be locked by the same covenant script
            let rem_spk_hash: u256 = get_output_script_hash(i_rem);
            let input_spk_hash: u256 = get_input_script_hash(i);
            assert!(jet::eq_256(rem_spk_hash, input_spk_hash));
        },
    };
}

// ============================================================================
// Main entry point
// ============================================================================

fn main() {
    let cosigner_sig: Signature = witness::COSIGNER_SIGNATURE;
    let i: u32 = jet::current_index();
    let i_rem: u32 = safe_add_32(i, 1);

    // Cosigner check (skipped if COSIGNER_PUBKEY == NUMS)
    check_cosigner(i, cosigner_sig);

    // Verify maker receive output script hash
    let out_spk_hash: u256 = get_output_script_hash(i);
    assert!(jet::eq_256(out_spk_hash, param::MAKER_RECEIVE_SPK_HASH));

    // Direction branch
    match param::IS_SELL_BASE {
        true => validate_sell_base_fill(i, i_rem),
        false => validate_sell_quote_fill(i, i_rem),
    };
}
